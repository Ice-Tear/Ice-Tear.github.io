---
layout:     post
title:      "Java中的内部类"
subtitle:   ""
date:       2017-09-19 10:00:00
author:     "吕兆晗"
header-img: "img/post-bg-digital-native.jpg"
tags:
    - Java内部类
    - JavaSE
---






# 内部类的定义
Java中允许在类中定义另一个类，这个定义在其他类内部的类就是***内部类（嵌套类）***，包含内部类的类也被称为***宿主类***。

# 内部类的作用
1. 内部类提供更好的封装。内部类**不允许**同一个包中的其他类访问该类。
2. 非静态内部类可以**直接访问**外部类的私有数据，但外部类不能访问内部类的实现细节（比如内部类的成员变量）。
3. 匿名内部类适用于创建那些仅需要一次使用的类。

# 内部类与外部类定义的语法区别
- 非静态内部类不能拥有静态成员。
- 内部类比外部类可以多使用三个修饰符：private、protected、static.
>*tip：外部类的修饰符只有两个：public和default。

# 内部类的种类
- **大部分时候**，内部类都被作为成员内部类定义。
- 成员内部类是一种**类成员**。
- 局部内部类和匿名内部类**不是**类成员。
>*tip：类成员有：成员变量，方法，构造器和初始化块。

### 1.成员内部类

- 非静态内部类
     1. 非静态内部类实例必须寄生在外部类实例里。
	 2. 非静态内部类可以直接访问外部类的私有成员。如果我们在外部类的其中一个方法中生成内部类的实例，那么它们在内存中的形式为：*图1*。
![图1：非静态内部类对象中保留外部类对象的引用内存示意图](/img/in-post/first-handler/01.png)
   3. 当外部类成员变量、内部类成员变量、内部类方法的局部变量同名时，调用的优先级为：局部变量>内部类成员变量>外部类成员变量。若想使用外部类的成员变量时可以用类.this.变量名，若想使用内部类的成员变量可以用this.变量名。
   4. 当外部类需要访问内部类的实例变量时，必须显式创建内部类对象。

```
public class Outer{
  private int outProp=9;

  class Inner{
    private int inProp=5;
    public void acessOuterProp(){
      //非静态内部类可以直接访问外部类的私有成员
      System.out.println("外部类的outProp值："+outProp);
    }
  }

  public void accessInnerProp(){
    //外部类不能直接访问内部类的私有成员
    //若要访问必须显式创建内部类对象
    System.out.println("内部类的InProp"+new Inner().inProp);
  }

  public static void main(String[] args){
      Outer out=new Outer();
      out.accessInnerProp();
  }
}
```

  5. 外部类的静态方法和静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量和创建实例。

  - 静态内部类 
  如果使用static修饰内部类，则这个内部类属于外部类本身，而不是外部类的对象。因此使用static修饰的内部类被称为**类内部类**，也叫**静态内部类**。  

  1. 静态内部类可以包含静态成员，也可以包含非静态成员。
  2. 静态内部类只能访问外部类的**类成员**。
  3. 外部类可以使用内部类的类名作为调用者来访问静态内部类的类成员。
  4. Java允许在接口中定义内部类，**接口内部类只能是静态内部类**。

  #### 2.局部内部类
 -  方法里定义的内部类叫做局部内部类。它的作用域只在这个方法内，不能在其他地方用。所以局部内部类没有访问控制符和static修饰。
> *tip：所有局部变量和局部内部类的上一级程序单元都是方法，所以没有访问控制符和static修饰。

- 编译后生成的class文件为：外部类$N局部内部类.class。因为一个类中可以有许多同名局部内部类，所以N是为了区分每个局部内部类。
- 局部内部类也**可以定义变量、创建实例或派生子类，但只能在方法内进行。**
- 局部内部类在实际开发中应用很少，因为我们使用类就是为了类的复用，但是局部内部类的作用域实在太小了。

#### 3.匿名内部类
- 匿名内部类是没有类名的类，适合那种只需要用一次的类。
- 匿名内部类在创建时就会立即创建一个实例。所以匿名内部类**不能是抽象类**。
- 匿名内部类**必须**继承一个父类或者实现一个接口。
- 匿名内部类不能定义构造器，因为匿名内部类没有类名。通过实现接口创建的匿名内部类只有隐式的无参构造器（其实是继承自Object的无参构造器），通过继承父类创建的匿名内部类拥有和父类相似的构造器（形参列表相同）。
> *tip：通过继承父类创建的匿名内部类的无参构造方法是父类的构造方法。

- Java要求被局部内部类、匿名内部类**访问的局部变量必须使用final修饰**。在Java8之后可以省略final修饰，但是被调用的局部变量还是会变成final变量（Java8新增的effectively final功能）。
> *tip：局部变量离开方法后就会失效，但匿名内部类不会，所以需要使用final修饰变量。用final修饰局部变量会使局部变量生命周期跟这个类一样。所以用final修饰后就不会出现匿名内部类想要用局部变量时局部变量被GC回收的尴尬情况。

# 使用内部类

1. 在外部类中使用内部类。
   与平常使用类没有太大区别，注意不要在静态成员中使用非静态内部类即可。
2. 在外部类外使用非静态内部类。
  - 在外部类外使用非静态内部类时，只能在其访问控制符对应的权限内使用，**非静态内部类不能被private修饰**。
  - 定义变量的语法如下： **外部类.内部类   变量名;
                                     OutClass.InnerClass varName;**
  - 创建对象的语法如下：**外部类.new   内部类的构造器;
                                     OutClass.new InnerClass();**
> *tip：非静态内部类的构造器必须由外部类的对象调用。

- ##### 当非静态内部类被继承时的用法。
```
public class SubClass extends Out.In{
  //构造器 
  public SubClass(Out out){
    //这里super是SubClass的父类，所以是Out.In类
    //通过外部类的对象out调用内部类的构造器
    out.super();
  } 
}
```
- 如果有一个内部类子类的对象存在，则一定有一个外部类对象。

3. 在外部类外使用静态内部类
  - 在外部类外使用静态内部类时无需创建外部类对象。
  - 定义变量的语法如下： **外部类.内部类   变量名;
                                     OutClass.InnerClass varName;**
  - 创建对象的语法如下：**外部类.内部类的构造器;
                                     OutClass.InnerClass();**
> *tip：静态内部类的构造器不需要外部类对象调用。

- 相比之下，使用静态内部类比非静态内部类方便的多，所以当需要使用内部类时**优先考虑使用静态内部类。**

#总结
##### 为什么Java要引入内部类的概念呢？
那是因为内部类具有一般类不具备的优点。
  1. **内部类提供更好的封装。**内部类可以使用private或protected修饰而外部类不行。
  2. **内部类可以实现多继承。**Java不像C++允许多继承，但是用内部类可以实现Java中的多继承。在一个类中可以用两个或多个内部类继承不同的父类实现多继承。

通过以上学习，我们对Java中内部类有了一些了解，这对以后我们学习Java8新增的Lambda表达式有一些概念性的铺垫，关于Java中的Lambda表达式我以后会更新。希望这篇文章能对学习内部类的你们有一些小帮助。